<html>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.4.11/d3.min.js"></script>
<script src="http://cpettitt.github.io/project/graphlib-dot/v0.4.10/graphlib-dot.min.js"></script>
<script>
(function() {
const GRAPH_FILE = 'https://raw.githubusercontent.com/wesalvaro/tokyo-dot/master/tokyo.dot';
const svg = d3.select('body')
    .append('svg')
    .attr('width', '100vw')
    .attr('height', '100vh');
const width = parseInt(svg.style('width'));
const height = parseInt(svg.style('height'));

const voronoi = d3.geom.voronoi()
  .x(function(d) { return d.x; })
  .y(function(d) { return d.y; })
  .clipExtent([[-10, -10], [width+10, height+10]]);

function recenterVoronoi(nodes) {
  const shapes = [];
  voronoi(nodes).forEach(function(d) {
    if ( !d.length ) return;
    var n = [];
    d.forEach(function(c){
      n.push([ c[0] - d.point.x, c[1] - d.point.y ]);
    });
    n.point = d.point;
    shapes.push(n);
  });
  return shapes;
}

const force = d3.layout.force()
  .charge(-2000)
  .friction(0.3)
  .linkDistance(50)
  .size([width, height]);
  
let node, link;

force.on('tick', function() {
    node.attr('transform', function(d) { return 'translate('+d.x+','+d.y+')'; })
        .attr('clip-path', function(d) { return 'url(#clip-'+d.index+')'; });

    link
      .attr('x1', function(d) { return d.source.x; })
      .attr('y1', function(d) { return d.source.y; })
      .attr('x2', function(d) { return d.target.x; })
      .attr('y2', function(d) { return d.target.y; });

    var clip = svg.selectAll('.clip')
        .data( recenterVoronoi(node.data()), function(d) { return d.point.index; } );

    clip.enter().append('clipPath')
        .attr('id', function(d) { return 'clip-'+d.point.index; })
        .attr('class', 'clip');
    clip.exit().remove()

    clip.selectAll('path').remove();
    clip.append('path')
        .attr('d', function(d) { return 'M'+d.join(',')+'Z'; });
});

d3.text(GRAPH_FILE, function(e, dot) {
  if (e) throw e;
  const graph = graphlibDot.parse(dot);
  const getName = (d) => d.label;
  const getColor = (d) => d3.rgb(d.color);
  const getStrokeWidth = (d) => (d.weight || 1);
  const getEdgeClass = (d) => 'link ' + (d.style == 'dashed' ? 'transfer' : 'rail');
  const getDashArray = (d) => d.style == 'dashed' ? '5,5' : 'solid';
  
  const nodes = [];
  const nodeIndexes = {};
  let nodeIndex = 0;
  graph.eachNode(function(id, node) {
    nodes.push(node);
    nodeIndexes[id] = nodeIndex++;
  });

  node = svg.selectAll('.node')
    .data(nodes)
    .enter().append('g')
    .attr('title', getName)
    .attr('class', 'node station')
    .call(force.drag);

  const edges = [];
  graph.eachEdge(function(id, source, target, edge) {
    edge.source = nodeIndexes[source];
    edge.target = nodeIndexes[target];
    edges.push(edge);
  });
  
  link = svg.selectAll('.link')
    .data(edges)
    .enter().append('line')
    .attr('class', getEdgeClass)
    .style('stroke', 'black')
    .style('stroke-dasharray', getDashArray)
    .style('stroke-width', getStrokeWidth);

  node.append('circle')
    .attr('r', 30)
    .attr('fill', getColor)
    .attr('fill-opacity', 0.5);

  node.append('circle')
    .attr('r', 4)
    .attr('stroke', 'black');

  force
    .nodes(nodes)
    .links(edges)
    .start();
});
  
}());
</script>
</body>
</html>
